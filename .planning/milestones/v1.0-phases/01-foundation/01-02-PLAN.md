---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/openclawpack/state/__init__.py
  - src/openclawpack/state/models.py
  - src/openclawpack/state/parser.py
  - src/openclawpack/state/reader.py
  - tests/test_state/__init__.py
  - tests/test_state/test_models.py
  - tests/test_state/test_parser.py
  - tests/test_state/test_reader.py
autonomous: true
requirements:
  - STATE-01
  - STATE-02

must_haves:
  truths:
    - "Calling the state reader on a .planning/ directory returns typed Pydantic models for config.json, STATE.md, ROADMAP.md, REQUIREMENTS.md, and PROJECT.md"
    - "State queries return structured data: current phase number, progress percentage, blocker list, and requirement completion status"
    - "Missing or malformed files produce partial results with defaults, not crashes"
    - "All state parsing works without spawning any subprocess"
  artifacts:
    - path: "src/openclawpack/state/models.py"
      provides: "Pydantic models for all .planning/ file types"
      exports: ["ProjectConfig", "ProjectState", "ProjectInfo", "PhaseInfo", "RequirementInfo", "RoadmapInfo", "PlanningDirectory"]
    - path: "src/openclawpack/state/parser.py"
      provides: "Markdown section extraction and file-specific parsers"
      exports: ["extract_section", "parse_state_md", "parse_roadmap_md", "parse_requirements_md", "parse_project_md"]
    - path: "src/openclawpack/state/reader.py"
      provides: "High-level state reader orchestrating all parsers"
      exports: ["read_project_state"]
  key_links:
    - from: "src/openclawpack/state/reader.py"
      to: "src/openclawpack/state/parser.py"
      via: "calls individual parse functions"
      pattern: "parse_(state|roadmap|requirements|project)_md"
    - from: "src/openclawpack/state/reader.py"
      to: "src/openclawpack/state/models.py"
      via: "constructs PlanningDirectory from parsed data"
      pattern: "PlanningDirectory\\("
    - from: "src/openclawpack/state/parser.py"
      to: "src/openclawpack/state/models.py"
      via: "returns typed model instances"
      pattern: "(ProjectState|PhaseInfo|RequirementInfo)\\("
---

<objective>
Build the state parser that reads .planning/ directory files into typed Pydantic models, providing structured project state data without any subprocess calls.

Purpose: Enable the `status` command and all state queries to return structured data (current phase, progress, blockers, requirements) by parsing the markdown and JSON files that GSD maintains in .planning/.

Output: Working state parser with models for all 5 file types, section-based markdown extraction, and a high-level reader that returns a complete PlanningDirectory model.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/config.json
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic models and markdown parser</name>
  <files>
    src/openclawpack/state/models.py
    src/openclawpack/state/parser.py
    tests/test_state/__init__.py
    tests/test_state/test_models.py
    tests/test_state/test_parser.py
  </files>
  <action>
    Create the data models and low-level parsing functions for .planning/ files.

    **src/openclawpack/state/models.py:**

    Define these Pydantic v2 models (use `from __future__ import annotations` for forward refs):

    `ProjectConfig(BaseModel)`: mode (str, default "yolo"), depth (str, default "standard"), parallelization (bool, default True), commit_docs (bool, default True), model_profile (str, default "quality"). Accepts extra fields via `model_config = ConfigDict(extra="allow")`.

    `PhaseInfo(BaseModel)`: number (int), name (str), goal (str | None), requirements (list[str], default []), plans_complete (int, default 0), plans_total (int, default 0), status (str, default "Not started"), completed_date (str | None, default None).

    `RequirementInfo(BaseModel)`: id (str), description (str), phase (int | None), completed (bool, default False).

    `ProjectState(BaseModel)`: current_phase (int), current_phase_name (str), plans_complete (int, default 0), plans_total (int, default 0), last_activity (str | None), blockers (list[str], default []), decisions (list[str], default []). Add `@computed_field` for `progress_percent: float` that returns `plans_complete / plans_total * 100` if plans_total > 0 else 0.0.

    `ProjectInfo(BaseModel)`: name (str), description (str), core_value (str | None), constraints (list[str], default []).

    `RoadmapInfo(BaseModel)`: phases (list[PhaseInfo], default []), overview (str | None).

    `PlanningDirectory(BaseModel)`: config (ProjectConfig), state (ProjectState), project (ProjectInfo), roadmap (RoadmapInfo), requirements (list[RequirementInfo], default []). Add `@computed_field` for `current_phase_info` (returns PhaseInfo for current phase or None) and `overall_progress` (float, total plans complete / total plans).

    **src/openclawpack/state/parser.py:**

    Core utility: `extract_section(content: str, header: str, level: int = 2) -> str | None` -- extracts markdown content under a heading. Uses regex pattern: `^{prefix}\s+{header}\s*\n(.*?)(?=^#{{1,{level}}}\s|\Z)` with MULTILINE | DOTALL.

    Helper: `parse_checkbox_items(section: str) -> list[tuple[bool, str]]` -- parses `- [ ]` and `- [x]` lines.

    Helper: `parse_table_rows(section: str) -> list[dict[str, str]]` -- parses markdown tables into list of dicts using header row for keys.

    File parsers (each takes `content: str`, returns the appropriate model):
    - `parse_config_json(content: str) -> ProjectConfig` -- `json.loads()` then `ProjectConfig.model_validate()`
    - `parse_state_md(content: str) -> ProjectState` -- extract "Current Position" section, parse phase number from "Phase: N of M", parse plans from "Plan: N of M", extract blockers from "Blockers/Concerns", extract decisions from "Decisions"
    - `parse_roadmap_md(content: str) -> RoadmapInfo` -- extract overview, parse "Phase Details" subsections for each phase, extract requirements list, plans count, status
    - `parse_requirements_md(content: str) -> list[RequirementInfo]` -- parse checkbox items with requirement IDs (bold `**ID**:`), extract phase from traceability table
    - `parse_project_md(content: str) -> ProjectInfo` -- extract name from H1, description from "What This Is", core_value from "Core Value", constraints from "Constraints"

    Each parser should handle missing sections gracefully (return defaults, not crash). Use the actual .planning/ files in this repo as reference for format.

    **tests/test_state/test_models.py:**
    - Test each model constructs with minimal required fields
    - Test ProjectState.progress_percent computed field (0 plans, some plans, all plans)
    - Test PlanningDirectory.current_phase_info returns correct phase
    - Test PlanningDirectory.overall_progress computes correctly

    **tests/test_state/test_parser.py:**
    - Test extract_section with known headers, missing headers, nested headers
    - Test parse_checkbox_items with checked, unchecked, and mixed items
    - Test parse_table_rows with a simple markdown table
    - Test each file parser against realistic content (use snippets from actual .planning/ files in this repo)
    - Test graceful degradation: parse_state_md with empty string returns defaults
  </action>
  <verify>
    Run: `cd /Users/mit/Documents/GitHub/openclawpack && python -m pytest tests/test_state/test_models.py tests/test_state/test_parser.py -v` -- all tests pass.
    Run: `python -c "from openclawpack.state.parser import parse_state_md; from pathlib import Path; print(parse_state_md(Path('.planning/STATE.md').read_text()))"` -- prints parsed ProjectState from actual project files.
  </verify>
  <done>All Pydantic models construct correctly. All parsers handle real .planning/ file content. Tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create state reader and integration tests</name>
  <files>
    src/openclawpack/state/reader.py
    src/openclawpack/state/__init__.py
    tests/test_state/test_reader.py
  </files>
  <action>
    Create the high-level state reader that orchestrates all parsers and wire up the state module exports.

    **src/openclawpack/state/reader.py:**

    `read_project_state(project_dir: str | Path) -> PlanningDirectory`:
    - Accept project directory path (convert to Path if string)
    - Construct planning_dir = project_dir / ".planning"
    - Check if planning_dir exists; raise `FileNotFoundError` with clear message if not
    - Read and parse each file, catching exceptions per-file:
      - `config.json` -> `parse_config_json()` or default `ProjectConfig()`
      - `STATE.md` -> `parse_state_md()` or raise (required file)
      - `ROADMAP.md` -> `parse_roadmap_md()` or default `RoadmapInfo()`
      - `REQUIREMENTS.md` -> `parse_requirements_md()` or default `[]`
      - `PROJECT.md` -> `parse_project_md()` or raise (required file)
    - Construct and return `PlanningDirectory` with all parsed data
    - Use `pathlib.Path` for all file operations (avoid hardcoded `.planning/` per research pitfall 6)

    `get_project_summary(project_dir: str | Path) -> dict`:
    - Convenience function that calls `read_project_state()` and returns a summary dict with:
      - `current_phase` (number)
      - `current_phase_name` (string)
      - `progress_percent` (float)
      - `blockers` (list)
      - `requirements_complete` (int -- count of completed requirements)
      - `requirements_total` (int -- count of all requirements)
    - This is what the `status` CLI command will use (wired in Phase 2, CMD-04 -- NOT in this plan)

    **src/openclawpack/state/__init__.py:**
    - Export: `read_project_state`, `get_project_summary`, `PlanningDirectory`, `ProjectState`, `ProjectConfig`, `ProjectInfo`, `RoadmapInfo`, `RequirementInfo`, `PhaseInfo`

    **tests/test_state/test_reader.py:**
    - Integration test: `read_project_state(".")` against THIS repo's .planning/ directory -- must return valid PlanningDirectory with current_phase=1, project name="OpenClawPack"
    - Test `get_project_summary(".")` returns dict with all expected keys
    - Test missing .planning/ directory raises FileNotFoundError with helpful message
    - Test partial .planning/ (create temp dir with only config.json and STATE.md and PROJECT.md) returns partial but valid result
  </action>
  <verify>
    Run: `cd /Users/mit/Documents/GitHub/openclawpack && python -m pytest tests/test_state/ -v` -- all tests pass.
    Run: `python -c "from openclawpack.state import read_project_state; s = read_project_state('.'); print(f'Phase {s.state.current_phase}: {s.state.current_phase_name}, Progress: {s.state.progress_percent}%')"` -- prints real project state.
    Run: `python -c "from openclawpack.state import get_project_summary; import json; print(json.dumps(get_project_summary('.'), indent=2))"` -- prints summary JSON.
  </verify>
  <done>State reader parses all 5 file types from .planning/. get_project_summary returns structured dict. Integration tests against real project files pass. Missing files degrade gracefully.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_state/ -v` -- all tests pass
2. `read_project_state(".")` returns PlanningDirectory with current_phase=1 from this project
3. `get_project_summary(".")` returns dict with phase, progress, blockers, requirements counts
4. Missing STATE.md raises clear FileNotFoundError
5. Missing optional files (REQUIREMENTS.md, ROADMAP.md) return defaults without crashing
</verification>

<success_criteria>
- All 5 .planning/ file types parse into typed Pydantic models
- State queries return current phase, progress percentage, blockers, requirement completion
- Graceful degradation on missing/malformed files
- No subprocess calls -- pure Python file I/O and regex parsing
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
