---
phase: 02-core-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/openclawpack/transport/types.py
  - src/openclawpack/transport/client.py
  - src/openclawpack/commands/__init__.py
  - src/openclawpack/commands/engine.py
  - src/openclawpack/commands/answers.py
  - src/openclawpack/cli.py
  - tests/test_transport/test_client.py
  - tests/test_commands/__init__.py
  - tests/test_commands/test_answers.py
  - tests/test_commands/test_engine.py
autonomous: true
requirements:
  - CMD-05
  - CMD-06
  - CMD-07
  - INT-05

must_haves:
  truths:
    - "TransportConfig accepts system_prompt (str or dict), setting_sources, max_turns, max_budget_usd, and ClaudeTransport.run() passes them to ClaudeAgentOptions plus accepts can_use_tool and hooks kwargs"
    - "Answer injection callback builder takes an answer map dict and returns a can_use_tool async callable that intercepts AskUserQuestion tool calls with fuzzy key matching and fallback to first option"
    - "Workflow engine constructs the correct prompt string, system_prompt preset, setting_sources, answer callback, and hooks for each GSD command type, then invokes ClaudeTransport.run()"
    - "All CLI commands accept --project-dir (defaults to cwd) and --verbose/--quiet flags via shared Typer options"
  artifacts:
    - path: "src/openclawpack/transport/types.py"
      provides: "Extended TransportConfig with system_prompt, setting_sources, max_turns, max_budget_usd fields"
      contains: "system_prompt"
    - path: "src/openclawpack/transport/client.py"
      provides: "Extended ClaudeTransport.run() passing new config fields and accepting can_use_tool/hooks kwargs"
      contains: "can_use_tool"
    - path: "src/openclawpack/commands/answers.py"
      provides: "build_answer_callback() creating can_use_tool callables from answer maps"
      exports: ["build_answer_callback"]
    - path: "src/openclawpack/commands/engine.py"
      provides: "WorkflowEngine with run_gsd_command() assembling prompt, config, and callbacks per command type"
      exports: ["WorkflowEngine"]
    - path: "src/openclawpack/cli.py"
      provides: "Four CLI commands (new-project, plan-phase, execute-phase, status) with shared --project-dir, --verbose, --quiet options"
      contains: "new_project"
  key_links:
    - from: "src/openclawpack/commands/engine.py"
      to: "src/openclawpack/transport/client.py"
      via: "WorkflowEngine instantiates ClaudeTransport and calls run()"
      pattern: "ClaudeTransport.*run"
    - from: "src/openclawpack/commands/engine.py"
      to: "src/openclawpack/commands/answers.py"
      via: "WorkflowEngine calls build_answer_callback() to create can_use_tool"
      pattern: "build_answer_callback"
    - from: "src/openclawpack/cli.py"
      to: "src/openclawpack/commands/engine.py"
      via: "CLI commands call WorkflowEngine methods"
      pattern: "WorkflowEngine"
---

<objective>
Extend the Phase 1 transport layer for Phase 2 SDK options (system_prompt presets, setting_sources, can_use_tool, hooks), build the answer injection engine for non-interactive GSD operation, create the workflow engine that translates high-level commands into GSD skill invocations, and wire all four CLI commands as thin dispatchers with shared --project-dir/--verbose/--quiet options.

Purpose: This plan establishes all shared infrastructure that the individual command workflows (Plans 02-02 and 02-03) depend on. Without transport extension, answer injection, and the workflow engine, no GSD command can run non-interactively.

Output: Extended transport config/client, answer injection module, workflow engine module, and CLI with 4 command stubs dispatching to workflow modules.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-commands/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@src/openclawpack/transport/types.py
@src/openclawpack/transport/client.py
@src/openclawpack/transport/__init__.py
@src/openclawpack/cli.py
@src/openclawpack/output/schema.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TransportConfig and ClaudeTransport for Phase 2 SDK options</name>
  <files>
    src/openclawpack/transport/types.py
    src/openclawpack/transport/client.py
    tests/test_transport/test_client.py
  </files>
  <action>
    Extend TransportConfig dataclass in types.py with 4 new optional fields:
    - `system_prompt: str | dict | None = None` — supports both raw string and SystemPromptPreset dict like `{"type": "preset", "preset": "claude_code", "append": "..."}`
    - `setting_sources: list[str] | None = None` — e.g., `["project"]` to load CLAUDE.md
    - `max_turns: int | None = None` — limits conversation turns
    - `max_budget_usd: float | None = None` — limits per-invocation spending

    Update ClaudeTransport.run() in client.py:
    1. Pass new config fields through to ClaudeAgentOptions construction:
       ```python
       setting_sources = kwargs.get("setting_sources", self.config.setting_sources)
       if setting_sources is not None:
           options.setting_sources = setting_sources
       max_turns = kwargs.get("max_turns", self.config.max_turns)
       if max_turns is not None:
           options.max_turns = max_turns
       max_budget_usd = kwargs.get("max_budget_usd", self.config.max_budget_usd)
       if max_budget_usd is not None:
           options.max_budget_usd = max_budget_usd
       ```
    2. Accept `can_use_tool` kwarg (async callable) and pass to `sdk_query()`:
       ```python
       can_use_tool = kwargs.pop("can_use_tool", None)
       hooks = kwargs.pop("hooks", None)
       # Pass to sdk_query:
       async for message in sdk_query(prompt=prompt, options=options, can_use_tool=can_use_tool, hooks=hooks):
       ```
    3. The existing system_prompt handling already works for both str and dict — verify it still works. The `system_prompt` field in TransportConfig type changes from `str | None` to `str | dict | None`.

    Add tests in test_client.py:
    - Test TransportConfig accepts new fields and defaults to None
    - Test ClaudeTransport.run() passes system_prompt dict through (mock sdk_query)
    - Test can_use_tool kwarg is forwarded to sdk_query (mock sdk_query to verify)
    - Test hooks kwarg is forwarded to sdk_query (mock sdk_query to verify)
    - Test setting_sources, max_turns, max_budget_usd are set on options when provided

    IMPORTANT: The existing tests must continue to pass. Only ADD tests, do not modify existing ones unless they test the fields being changed.
  </action>
  <verify>
    Run `python -m pytest tests/test_transport/ -v` — all existing + new tests pass.
  </verify>
  <done>
    TransportConfig has 4 new fields (system_prompt type widened to str|dict|None, setting_sources, max_turns, max_budget_usd). ClaudeTransport.run() accepts and forwards can_use_tool and hooks kwargs to sdk_query. All transport tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build answer injection, workflow engine, and CLI command dispatchers</name>
  <files>
    src/openclawpack/commands/__init__.py
    src/openclawpack/commands/answers.py
    src/openclawpack/commands/engine.py
    src/openclawpack/cli.py
    tests/test_commands/__init__.py
    tests/test_commands/test_answers.py
    tests/test_commands/test_engine.py
  </files>
  <action>
    **1. Create `src/openclawpack/commands/__init__.py`:**
    Module docstring, export WorkflowEngine and build_answer_callback. Use lazy imports to avoid loading SDK at CLI module level (same pattern as transport/__init__.py).

    **2. Create `src/openclawpack/commands/answers.py`:**
    Contains `build_answer_callback(answer_map: dict[str, str])` function that returns an async `can_use_tool` callable:
    - The callback checks if `tool_name == "AskUserQuestion"`
    - For each question in `tool_input["questions"]`, attempts matching:
      a. Exact match: `question_text` in `answer_map`
      b. Substring/fuzzy match: any key in `answer_map` that is a substring of `question_text` (case-insensitive)
      c. Fallback: if question has `options`, select the first option's `label`; otherwise use empty string
    - Returns `PermissionResultAllow(updated_input={"questions": questions, "answers": answers_dict})`
    - For non-AskUserQuestion tools, returns `PermissionResultAllow()` (allow all)
    - Log unmatched questions at warning level using standard `logging` module

    Also contains `build_noop_pretool_hook()` that returns an async no-op `PreToolUse` hook function. This is REQUIRED for `can_use_tool` to fire in the Python SDK (see Pitfall 1 in research).

    IMPORTANT: Import `PermissionResultAllow` from `claude_agent_sdk` lazily inside the callback function, NOT at module level. This preserves the CLI independence requirement (PKG-04).

    **3. Create `src/openclawpack/commands/engine.py`:**
    Contains `WorkflowEngine` class with:
    - `__init__(self, project_dir: str | None = None, verbose: bool = False, quiet: bool = False, timeout: float | None = None)` — stores config
    - `async def run_gsd_command(self, command: str, prompt_args: str = "", answer_map: dict[str, str] | None = None, prompt_override: str | None = None) -> CommandResult` — the core method:
      a. Constructs prompt: if `prompt_override` is provided, uses it directly; otherwise constructs `f"/{command}{' ' + prompt_args if prompt_args else ''}"`
      b. Builds TransportConfig with:
         - `cwd=self.project_dir or os.getcwd()`
         - `system_prompt={"type": "preset", "preset": "claude_code", "append": "Execute the following command non-interactively. Do not ask unnecessary clarifying questions."}`
         - `setting_sources=["project"]`
         - `timeout_seconds=self.timeout or DEFAULT_TIMEOUTS.get(command, 600)`
      c. If `answer_map` provided, calls `build_answer_callback(answer_map)` and `build_noop_pretool_hook()`
      d. Creates `ClaudeTransport(config)` and calls `await transport.run(prompt, can_use_tool=callback, hooks=hooks)`
      e. Returns the CommandResult
    - `def run_gsd_command_sync(self, ...) -> CommandResult` — sync wrapper using `anyio.from_thread.run()`

    Default timeouts dict:
    ```python
    DEFAULT_TIMEOUTS: dict[str, float] = {
        "gsd:new-project": 900,
        "gsd:plan-phase": 600,
        "gsd:execute-phase": 1200,
    }
    ```

    **4. Update `src/openclawpack/cli.py`:**
    Replace the current stub with full CLI structure. IMPORTANT: Keep the lazy import pattern — do NOT import commands/transport at module level.

    Add shared options using a Typer callback:
    ```python
    @app.callback()
    def main(
        version: bool = typer.Option(False, "--version", "-v", callback=version_callback, is_eager=True, help="Show version and exit."),
        project_dir: str = typer.Option(None, "--project-dir", "-d", help="Project directory (defaults to cwd)."),
        verbose: bool = typer.Option(False, "--verbose", help="Show detailed subprocess output."),
        quiet: bool = typer.Option(False, "--quiet", "-q", help="Suppress all non-JSON output."),
        ctx: typer.Context = ...,
    ) -> None:
        ctx.ensure_object(dict)
        ctx.obj["project_dir"] = project_dir
        ctx.obj["verbose"] = verbose
        ctx.obj["quiet"] = quiet
    ```

    Add 4 thin CLI commands (all use lazy imports):

    a. `@app.command("new-project")` accepting `idea: str = typer.Argument(...)` plus optional `--idea-file` for file path, `--timeout` override. Dispatches to workflow module (imported lazily inside function body). Prints CommandResult JSON to stdout.

    b. `@app.command("plan-phase")` accepting `phase: int = typer.Argument(...)`, `--timeout`. Dispatches to workflow module.

    c. `@app.command("execute-phase")` accepting `phase: int = typer.Argument(...)`, `--timeout`. Dispatches to workflow module.

    d. `@app.command()` for `status` — reads state directly via `get_project_summary()` (no subprocess needed). Wraps in CommandResult.ok() and prints JSON.

    Output helper function `_output(result: CommandResult, quiet: bool)` — if not quiet, prints `result.to_json()` to stdout.

    **BINDING CONTRACT for Plans 02-02 and 02-03:** The CLI command stubs use the following import paths and function signatures. Plans 02-02 and 02-03 MUST create modules matching these exactly:
    - `from openclawpack.commands.status import status_workflow` — signature: `status_workflow(project_dir: str | None = None) -> CommandResult`
    - `from openclawpack.commands.new_project import new_project_workflow` — signature: `async new_project_workflow(idea: str, project_dir: str | None = None, verbose: bool = False, quiet: bool = False, timeout: float | None = None, answer_overrides: dict[str, str] | None = None) -> CommandResult`
    - `from openclawpack.commands.plan_phase import plan_phase_workflow` — signature: `async plan_phase_workflow(phase: int, project_dir: str | None = None, verbose: bool = False, quiet: bool = False, timeout: float | None = None, answer_overrides: dict[str, str] | None = None) -> CommandResult`
    - `from openclawpack.commands.execute_phase import execute_phase_workflow` — signature: `async execute_phase_workflow(phase: int, project_dir: str | None = None, verbose: bool = False, quiet: bool = False, timeout: float | None = None, answer_overrides: dict[str, str] | None = None) -> CommandResult`

    Plans 02-02 and 02-03 MUST also add `src/openclawpack/cli.py` to their files_modified and include a final wiring step to verify the CLI dispatch works end-to-end after creating the workflow modules.

    **5. Create test files:**
    - `tests/test_commands/__init__.py` — empty
    - `tests/test_commands/test_answers.py`:
      - Test exact match answer injection
      - Test substring/fuzzy match
      - Test fallback to first option when no match
      - Test non-AskUserQuestion tools pass through
      - Test build_noop_pretool_hook returns async callable
    - `tests/test_commands/test_engine.py`:
      - Test prompt construction for each command type
      - Test default timeout selection per command
      - Test project_dir propagation to TransportConfig
      - Test answer_map wiring to build_answer_callback (mock transport)

    For answer injection tests, DO NOT import from claude_agent_sdk. Instead, test the callback by calling it directly with mock tool_name/tool_input dicts, and mock PermissionResultAllow. Use `unittest.mock.patch` to mock the lazy import inside the callback.
  </action>
  <verify>
    Run `python -m pytest tests/test_commands/ -v` — all new tests pass.
    Run `python -m pytest tests/ -v` — full test suite passes (including existing transport and output tests).
    Run `openclawpack --help` — shows all 4 commands (new-project, plan-phase, execute-phase, status).
    Run `openclawpack status --help` — shows --project-dir, --verbose, --quiet options.
    Run `openclawpack new-project --help` — shows idea argument and options.
  </verify>
  <done>
    Answer injection module builds can_use_tool callbacks from answer maps with exact/fuzzy/fallback matching. Workflow engine translates command names into GSD skill prompts with correct system_prompt presets, setting_sources, timeouts, and answer callbacks. CLI shows all 4 commands with shared --project-dir/--verbose/--quiet options. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` — full suite passes (transport + commands + output)
2. `openclawpack --help` — lists new-project, plan-phase, execute-phase, status
3. `openclawpack --version` — still works without Claude Code (lazy imports preserved)
4. `openclawpack status --help` — shows --project-dir flag
5. `openclawpack new-project --help` — shows idea argument
</verification>

<success_criteria>
- TransportConfig extended with system_prompt (str|dict), setting_sources, max_turns, max_budget_usd
- ClaudeTransport.run() forwards can_use_tool and hooks to sdk_query
- build_answer_callback() creates AskUserQuestion interceptors with fuzzy matching
- WorkflowEngine.run_gsd_command() assembles correct prompts, configs, and callbacks per command
- CLI has 4 commands with shared --project-dir/--verbose/--quiet options
- All tests pass, CLI help works without Claude Code
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-commands/02-01-SUMMARY.md`
</output>
