---
phase: 02.1-integration-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/openclawpack/transport/client.py
  - src/openclawpack/commands/answers.py
  - tests/test_transport/test_client.py
  - tests/test_commands/test_answers.py
autonomous: true
requirements:
  - CMD-05

must_haves:
  truths:
    - "can_use_tool and hooks are set on ClaudeAgentOptions fields, never passed as sdk_query() kwargs"
    - "When can_use_tool is set, the prompt is wrapped as an AsyncIterable before passing to sdk_query()"
    - "Hooks are wrapped in HookMatcher objects with correct list[HookMatcher] structure"
    - "The noop PreToolUse hook callback matches the SDK HookCallback signature (HookInput, str|None, HookContext) -> HookJSONOutput"
    - "Test mocks for sdk_query enforce the real 3-argument keyword-only signature and reject extra kwargs"
  artifacts:
    - path: "src/openclawpack/transport/client.py"
      provides: "Fixed sdk_query() call -- can_use_tool/hooks on options, async prompt wrapping"
      contains: "options.can_use_tool"
    - path: "src/openclawpack/commands/answers.py"
      provides: "HookMatcher-wrapped hooks, corrected hook callback signature"
      contains: "HookMatcher"
  key_links:
    - from: "src/openclawpack/transport/client.py"
      to: "claude_agent_sdk.query"
      via: "sdk_query(prompt=..., options=...) with only 2-3 kwargs"
      pattern: "sdk_query\\(prompt=.*options="
    - from: "src/openclawpack/commands/answers.py"
      to: "claude_agent_sdk.HookMatcher"
      via: "import and wrapping of hook callbacks"
      pattern: "HookMatcher"
---

<objective>
Fix SDK wiring so that `can_use_tool` and `hooks` reach the claude-agent-sdk correctly, enabling answer injection for non-interactive command execution.

Purpose: Without these fixes, any command using answer injection (new-project, plan-phase, execute-phase) raises `TypeError` at runtime because `sdk_query()` rejects unexpected keyword arguments. The hooks structure and callback signature are also mismatched with what the SDK expects.

Output: Working `client.py` that correctly wires `can_use_tool`/`hooks` onto `ClaudeAgentOptions`, wraps prompts as `AsyncIterable` when needed, and `answers.py` with correct `HookMatcher` wrapping and callback signatures. Tests enforce the real `sdk_query` signature.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-integration-fixes/2.1-RESEARCH.md

@src/openclawpack/transport/client.py
@src/openclawpack/commands/answers.py
@tests/test_transport/test_client.py
@tests/test_commands/test_answers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix client.py SDK wiring -- options fields + async prompt wrapper</name>
  <files>src/openclawpack/transport/client.py</files>
  <action>
Fix three bugs in `ClaudeTransport.run()`:

**Bug 1 -- can_use_tool/hooks as sdk_query kwargs (lines 102-115):**
Remove the `query_kwargs` dict pattern that passes `can_use_tool` and `hooks` as kwargs to `sdk_query()`. Instead, set them directly on the `ClaudeAgentOptions` object:
```python
if can_use_tool is not None:
    options.can_use_tool = can_use_tool
if hooks is not None:
    options.hooks = hooks
```
Then call `sdk_query(prompt=..., options=options)` with only `prompt` and `options` kwargs.

**Bug 2 -- AsyncIterable prompt when can_use_tool is set (Pitfall 2 from research):**
The SDK raises `ValueError("can_use_tool callback requires streaming mode")` if `can_use_tool` is set but prompt is a plain string. Add a private async generator helper at module level:
```python
from typing import Any, AsyncIterator
from collections.abc import AsyncIterable

async def _wrap_prompt_as_stream(prompt_text: str) -> AsyncIterator[dict[str, Any]]:
    """Wrap a string prompt as an AsyncIterable for streaming mode."""
    yield {
        "type": "user",
        "session_id": "",
        "message": {"role": "user", "content": prompt_text},
        "parent_tool_use_id": None,
    }
```
In `run()`, after setting `options.can_use_tool`, determine the prompt input:
```python
if options.can_use_tool is not None:
    prompt_input: str | AsyncIterable[dict[str, Any]] = _wrap_prompt_as_stream(prompt)
else:
    prompt_input = prompt

async for message in sdk_query(prompt=prompt_input, options=options):
    ...
```

**Bug 3 -- verbose/quiet/stderr support preparation:**
Add optional `verbose` and `quiet` kwargs to `run()` (popped from kwargs alongside `can_use_tool` and `hooks`). When `verbose=True`, set `options.stderr` to a callback that prints to sys.stderr. When `quiet=True`, explicitly set `options.stderr = None` to suppress any SDK stderr output:
```python
verbose = kwargs.pop("verbose", False)
quiet = kwargs.pop("quiet", False)
# ... after building options ...
if quiet:
    options.stderr = None  # suppress all SDK stderr output
elif verbose:
    import sys as _sys
    options.stderr = lambda line: print(line, file=_sys.stderr)
```
Note: `quiet` takes precedence over `verbose` if both are somehow set (defensive). This prepares client.py for Plan 02 to wire both verbose and quiet through from the engine.

Do NOT change the exception handling block or the `run_sync()` method. The `asyncio.timeout` wrapper stays the same.
  </action>
  <verify>
Run `python -c "from openclawpack.transport.client import ClaudeTransport; print('import ok')"` to confirm no syntax errors.

Run `pytest tests/test_transport/test_client.py -x -v` -- existing tests should still pass (they mock sdk_query so the wiring change is transparent to permissive mocks). Some tests may need adjustment in Task 2.
  </verify>
  <done>
`client.py` sets `can_use_tool` and `hooks` on `ClaudeAgentOptions` fields, wraps prompt as `AsyncIterable` when `can_use_tool` is set, and supports `verbose` and `quiet` kwargs for `stderr` control (`verbose` enables stderr output, `quiet` suppresses it). The `sdk_query()` call uses only `prompt` and `options` keyword arguments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix answers.py hook structure + update tests for strict SDK signature</name>
  <files>
    src/openclawpack/commands/answers.py
    tests/test_transport/test_client.py
    tests/test_commands/test_answers.py
  </files>
  <action>
**Fix 1 -- answers.py `build_noop_pretool_hook()` (lines 99-113):**
The function currently returns `async def pre_tool_use(session, event) -> None` which does not match the SDK's `HookCallback` type: `(HookInput, str | None, HookContext) -> Awaitable[HookJSONOutput]`.

Update the function to return a correctly-typed callback:
```python
def build_noop_pretool_hook() -> Callable[..., Coroutine[Any, Any, dict]]:
    """Create a no-op PreToolUse hook callback matching the SDK HookCallback signature."""
    async def pre_tool_use(
        input: Any,          # HookInput
        tool_use_id: Any,    # str | None
        context: Any,        # HookContext
    ) -> dict:
        """No-op hook -- allow all tool use."""
        return {}  # empty SyncHookJSONOutput = proceed normally

    return pre_tool_use
```
Use `Any` for the parameter types rather than importing SDK types directly, to preserve PKG-04 lazy import compatibility (this module must be importable without the SDK). The return is `dict` (compatible with `HookJSONOutput` TypedDict).

**Fix 2 -- answers.py: new `build_hooks_dict()` helper:**
Add a new function that wraps the noop hook in the correct `dict[HookEvent, list[HookMatcher]]` structure that the SDK expects. This function DOES lazy-import from the SDK:
```python
def build_hooks_dict() -> dict[str, list]:
    """Build hooks dict in SDK-expected format: {HookEvent: [HookMatcher(hooks=[callback])]}."""
    from claude_agent_sdk import HookMatcher
    return {
        "PreToolUse": [HookMatcher(hooks=[build_noop_pretool_hook()])]
    }
```
This keeps the HookMatcher import lazy (inside the function body).

**Fix 3 -- Update `test_client.py` mocks to enforce strict sdk_query signature:**
In `TestClaudeTransportRunForwarding`, replace all `async def fake_query(**kw)` with a strict version:
```python
async def fake_query(*, prompt, options, transport=None):
    """Mock enforcing real sdk_query() signature -- keyword-only, 3 args max."""
    from claude_agent_sdk import ResultMessage
    msg = ResultMessage.__new__(ResultMessage)
    msg.is_error = False
    msg.result = "ok"
    msg.session_id = "s1"
    msg.usage = {}
    msg.duration_ms = 1
    yield msg
```
This ensures tests FAIL if client.py ever passes extra kwargs to sdk_query again.

Update the specific test assertions:
- `test_can_use_tool_forwarded`: Assert `options.can_use_tool is my_can_use_tool` (on the options object, not as a top-level kwarg)
- `test_hooks_forwarded`: Assert `options.hooks is hooks` (on the options object)
- `test_can_use_tool_not_passed_when_none`: Assert `options.can_use_tool is None` and `options.hooks is None`

For the `can_use_tool` test, the prompt will now be an `AsyncIterable` (not a string). Update the assertion: instead of checking `captured_kwargs["prompt"] == "test"`, verify the prompt is an async iterable when `can_use_tool` is set.

**Fix 4 -- Update `test_answers.py` for build_hooks_dict:**
Add a test that `build_hooks_dict()` returns the correct structure:
```python
def test_build_hooks_dict_returns_hookmatcher_list():
    from openclawpack.commands.answers import build_hooks_dict
    from claude_agent_sdk import HookMatcher
    result = build_hooks_dict()
    assert "PreToolUse" in result
    assert isinstance(result["PreToolUse"], list)
    assert len(result["PreToolUse"]) == 1
    assert isinstance(result["PreToolUse"][0], HookMatcher)
```

Add a test for the updated `build_noop_pretool_hook` signature:
```python
@pytest.mark.anyio
async def test_noop_hook_accepts_three_args():
    from openclawpack.commands.answers import build_noop_pretool_hook
    hook = build_noop_pretool_hook()
    result = await hook("fake_input", "tool-123", "fake_context")
    assert result == {}
```
  </action>
  <verify>
Run `pytest tests/test_transport/test_client.py tests/test_commands/test_answers.py -x -v` -- all tests pass.

Run `pytest tests/ -x -v` -- full test suite passes (210+ tests).
  </verify>
  <done>
`build_noop_pretool_hook()` returns a callback with the correct 3-parameter SDK signature returning `dict`. `build_hooks_dict()` wraps the callback in `HookMatcher`. Test mocks for `sdk_query` enforce the strict keyword-only 3-argument signature. `can_use_tool` and `hooks` assertions verify they appear on `ClaudeAgentOptions` fields, not as top-level kwargs.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -x -v` -- full test suite passes
2. `python -c "from openclawpack.transport.client import ClaudeTransport; from openclawpack.commands.answers import build_hooks_dict; print('imports ok')"` -- no import errors
3. Grep `client.py` for `query_kwargs["can_use_tool"]` -- should NOT appear (old pattern removed)
4. Grep `client.py` for `options.can_use_tool` -- should appear (new pattern)
5. Grep `answers.py` for `HookMatcher` -- should appear in `build_hooks_dict()`
</verification>

<success_criteria>
- `sdk_query()` is called with ONLY `prompt` and `options` keyword arguments (no extra kwargs)
- `can_use_tool` and `hooks` are set as fields on `ClaudeAgentOptions` before the call
- When `can_use_tool` is set, prompt is wrapped as `AsyncIterable` (not passed as string)
- Hook callbacks use the 3-parameter SDK signature (input, tool_use_id, context) -> dict
- Hooks are wrapped in `HookMatcher` objects
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-integration-fixes/02.1-01-SUMMARY.md`
</output>
