---
phase: 02.1-integration-fixes
plan: 02
type: execute
wave: 2
depends_on:
  - "02.1-01"
files_modified:
  - src/openclawpack/commands/engine.py
  - src/openclawpack/commands/new_project.py
  - src/openclawpack/commands/plan_phase.py
  - src/openclawpack/commands/execute_phase.py
  - tests/test_commands/test_engine.py
  - tests/test_commands/test_new_project.py
  - tests/test_commands/test_plan_phase.py
  - tests/test_commands/test_execute_phase.py
autonomous: true
requirements:
  - CMD-05
  - CMD-07

must_haves:
  truths:
    - "When Claude Code CLI is not installed, running any workflow function returns CommandResult.error() with a message, not a Python traceback"
    - "WorkflowEngine passes verbose flag through to ClaudeTransport.run() so SDK emits stderr debug output"
    - "WorkflowEngine uses build_hooks_dict() from answers.py to produce correct HookMatcher structure (not bare callable)"
    - "All three workflow functions (new_project, plan_phase, execute_phase) catch TransportError and return structured error output"
    - "Test mocks in engine/workflow tests enforce that can_use_tool and hooks are passed via run() kwargs correctly"
  artifacts:
    - path: "src/openclawpack/commands/engine.py"
      provides: "Verbose forwarding to transport, build_hooks_dict() usage, TransportError catching"
      contains: "build_hooks_dict"
    - path: "src/openclawpack/commands/new_project.py"
      provides: "TransportError -> CommandResult.error() wrapping"
      contains: "TransportError"
    - path: "src/openclawpack/commands/plan_phase.py"
      provides: "TransportError -> CommandResult.error() wrapping"
      contains: "TransportError"
    - path: "src/openclawpack/commands/execute_phase.py"
      provides: "TransportError -> CommandResult.error() wrapping"
      contains: "TransportError"
  key_links:
    - from: "src/openclawpack/commands/engine.py"
      to: "src/openclawpack/transport/client.py"
      via: "verbose kwarg passed through to ClaudeTransport.run()"
      pattern: "run\\(.*verbose="
    - from: "src/openclawpack/commands/engine.py"
      to: "src/openclawpack/commands/answers.py"
      via: "build_hooks_dict() replacing bare dict literal"
      pattern: "build_hooks_dict\\(\\)"
    - from: "src/openclawpack/commands/new_project.py"
      to: "src/openclawpack/transport/errors.py"
      via: "try/except TransportError -> CommandResult.error()"
      pattern: "except TransportError"
---

<objective>
Wire verbose flag through the engine to the SDK, fix hooks structure in the engine, and add structured error propagation at the workflow boundary so that transport failures return JSON errors instead of tracebacks.

Purpose: Without error catching, users see raw Python tracebacks when Claude Code is missing. Without verbose forwarding, the `--verbose` flag is accepted but ignored. Without `build_hooks_dict()`, the engine passes a bare callable where the SDK expects `list[HookMatcher]`.

Output: All three workflow modules catch `TransportError` and return `CommandResult.error()`. The engine forwards `verbose` to `ClaudeTransport.run()` and uses `build_hooks_dict()` for correct hook structure. Tests validate all behaviors.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-integration-fixes/2.1-RESEARCH.md
@.planning/phases/02.1-integration-fixes/02.1-01-SUMMARY.md

@src/openclawpack/commands/engine.py
@src/openclawpack/commands/new_project.py
@src/openclawpack/commands/plan_phase.py
@src/openclawpack/commands/execute_phase.py
@src/openclawpack/transport/errors.py
@tests/test_commands/test_engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix engine.py -- verbose forwarding, build_hooks_dict(), and error catching</name>
  <files>src/openclawpack/commands/engine.py</files>
  <action>
Three changes to `WorkflowEngine.run_gsd_command()`:

**Change 1 -- Use `build_hooks_dict()` instead of bare dict (line 110):**
Replace:
```python
run_kwargs["hooks"] = {"PreToolUse": build_noop_pretool_hook()}
```
With:
```python
from openclawpack.commands.answers import build_hooks_dict
# ... (add to existing lazy imports block at top of method)
run_kwargs["hooks"] = build_hooks_dict()
```
Update the lazy import block (lines 73-76) to import `build_hooks_dict` instead of `build_noop_pretool_hook`:
```python
from openclawpack.commands.answers import (
    build_answer_callback,
    build_hooks_dict,
)
```
Remove the `build_noop_pretool_hook` import since it is no longer called directly from the engine.

**Change 2 -- Forward verbose flag to transport.run() (new):**
After building `run_kwargs` dict, add:
```python
if self.verbose:
    run_kwargs["verbose"] = True
```
This passes `verbose=True` through to `ClaudeTransport.run()` which (from Plan 01) pops it and sets `options.stderr`.

**Change 3 -- Catch TransportError at engine boundary (wrap `transport.run()` call):**
Wrap the `transport.run()` call in a try/except:
```python
from openclawpack.transport.errors import TransportError
# ... (add to lazy imports block)

try:
    return await transport.run(prompt, **run_kwargs)
except TransportError as e:
    return CommandResult.error(str(e))
```
This ensures that CLINotFound, ProcessError, TransportTimeout, etc. all produce structured `CommandResult.error()` responses instead of propagating as unhandled exceptions.

The `CommandResult` import already exists at the top of the module, so no new top-level imports are needed. The `TransportError` import is lazy (inside the method body) to maintain PKG-04 compliance.
  </action>
  <verify>
Run `python -c "from openclawpack.commands.engine import WorkflowEngine; print('import ok')"` -- no syntax errors.

Run `pytest tests/test_commands/test_engine.py -x -v` -- existing tests pass (they mock ClaudeTransport so error catching is transparent). Some may need adjustment in Task 2.
  </verify>
  <done>
`WorkflowEngine` uses `build_hooks_dict()` for correct HookMatcher structure, forwards `verbose` to `ClaudeTransport.run()`, and catches `TransportError` to return `CommandResult.error()` instead of propagating exceptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TransportError catching to workflow modules + update all tests</name>
  <files>
    src/openclawpack/commands/new_project.py
    src/openclawpack/commands/plan_phase.py
    src/openclawpack/commands/execute_phase.py
    tests/test_commands/test_engine.py
    tests/test_commands/test_new_project.py
    tests/test_commands/test_plan_phase.py
    tests/test_commands/test_execute_phase.py
  </files>
  <action>
**Part A -- Workflow module error wrapping:**

For each of the three workflow modules (`new_project.py`, `plan_phase.py`, `execute_phase.py`), the engine-level error catching from Task 1 handles most cases. However, add a defensive try/except at the workflow function level as well (belt-and-suspenders) to catch any errors that occur BEFORE the engine call (e.g., during WorkflowEngine construction if somehow the import itself fails):

In each workflow's async function, wrap the engine creation and call:
```python
async def XXX_workflow(...) -> CommandResult:
    try:
        from openclawpack.commands.engine import WorkflowEngine
        # ... existing code ...
        return await engine.run_gsd_command(...)
    except Exception as e:
        # Catch-all so CLI never shows raw tracebacks
        from openclawpack.output.schema import CommandResult as CR
        return CR.error(str(e))
```
Use a broad `Exception` catch at the workflow boundary (the engine already narrows to `TransportError`). This is the outermost defense before CLI output.

Do this for:
1. `new_project_workflow()` in `new_project.py`
2. `plan_phase_workflow()` in `plan_phase.py`
3. `execute_phase_workflow()` in `execute_phase.py`

**Part B -- Engine test updates (`test_engine.py`):**

Add tests to `TestAnswerMapWiring`:

1. `test_answer_map_uses_hooks_dict_with_hookmatcher`: When `answer_map` is provided, verify the `hooks` kwarg contains `HookMatcher` objects (not bare callables). Mock `ClaudeTransport` and capture `run()` kwargs. Assert:
   ```python
   from claude_agent_sdk import HookMatcher
   hooks = captured_kwargs["hooks"]
   assert "PreToolUse" in hooks
   assert isinstance(hooks["PreToolUse"], list)
   assert isinstance(hooks["PreToolUse"][0], HookMatcher)
   ```

2. `test_verbose_forwarded_to_transport_run`: Create engine with `verbose=True`, run a command, capture `run()` kwargs, assert `captured_kwargs["verbose"] is True`.

3. `test_verbose_not_forwarded_when_false`: Create engine with `verbose=False`, run a command, assert `"verbose" not in captured_kwargs`.

4. `test_transport_error_returns_command_result_error`: Mock `ClaudeTransport.run` to raise `CLINotFound("CLI not found")`. Assert that `run_gsd_command` returns `CommandResult` with `success=False` and `"CLI not found"` in errors:
   ```python
   from openclawpack.transport.errors import CLINotFound
   async def mock_run(prompt, **kwargs):
       raise CLINotFound("CLI not found")
   # ... setup mock ...
   result = await engine.run_gsd_command("gsd:new-project")
   assert result.success is False
   assert "CLI not found" in result.errors[0]
   ```

**Part C -- Workflow test updates:**

For each of `test_new_project.py`, `test_plan_phase.py`, `test_execute_phase.py`, add one test each:

1. `test_XXX_workflow_returns_error_on_transport_failure`: Mock `WorkflowEngine` at `openclawpack.commands.engine.WorkflowEngine` to have `run_gsd_command` raise a `TransportError`. Call the workflow function and assert it returns `CommandResult` with `success=False` (not raises).

Example for `test_new_project.py`:
```python
@pytest.mark.anyio
async def test_new_project_workflow_returns_error_on_failure():
    from openclawpack.commands.new_project import new_project_workflow
    with patch("openclawpack.commands.engine.WorkflowEngine") as MockEngine:
        instance = MockEngine.return_value
        instance.run_gsd_command = AsyncMock(
            side_effect=Exception("Transport failed")
        )
        result = await new_project_workflow(idea="test idea")
    assert result.success is False
    assert "Transport failed" in result.errors[0]
```
  </action>
  <verify>
Run `pytest tests/test_commands/ -x -v` -- all command tests pass.

Run `pytest tests/ -x -v` -- full test suite passes.

Verify no tracebacks: `python -c "import asyncio; from openclawpack.commands.new_project import new_project_workflow; r = asyncio.run(new_project_workflow('test')); print(r.success, r.errors)"` -- should print `False ['...']` (structured error), not a traceback. (This will hit CLINotFound or similar since Claude Code likely isn't configured for test.)
  </verify>
  <done>
All three workflow functions catch exceptions and return `CommandResult.error()`. Engine tests verify HookMatcher structure in hooks, verbose forwarding, and TransportError handling. Workflow tests verify error-to-CommandResult wrapping. No raw tracebacks escape to the CLI.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -x -v` -- full test suite passes (210+ existing + new tests)
2. Grep `engine.py` for `build_hooks_dict` -- confirms correct hook builder usage
3. Grep `engine.py` for `TransportError` -- confirms error catching
4. Grep `engine.py` for `verbose` -- confirms flag forwarding
5. Grep `new_project.py` for `except` -- confirms error wrapping
6. Grep `plan_phase.py` for `except` -- confirms error wrapping
7. Grep `execute_phase.py` for `except` -- confirms error wrapping
</verification>

<success_criteria>
- `WorkflowEngine` uses `build_hooks_dict()` producing `list[HookMatcher]` structure
- `WorkflowEngine` forwards `verbose=True` to `ClaudeTransport.run()` when engine is verbose
- `WorkflowEngine` catches `TransportError` and returns `CommandResult.error()`
- All three workflow functions have defensive error catching returning `CommandResult.error()`
- Tests verify HookMatcher structure, verbose forwarding, error catching at engine level, and error wrapping at workflow level
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-integration-fixes/02.1-02-SUMMARY.md`
</output>
