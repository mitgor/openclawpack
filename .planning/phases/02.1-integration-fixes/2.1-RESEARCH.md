# Phase 2.1: Integration Fixes - Research

**Researched:** 2026-02-22
**Domain:** Claude Agent SDK wiring, error propagation, verbose/quiet forwarding
**Confidence:** HIGH

## Summary

Phase 2.1 addresses three integration bugs discovered during the v1.0 milestone audit. All three are wiring issues between openclawpack's transport/engine layers and the claude-agent-sdk v0.1.39 API -- not design flaws.

The most critical bug is that `sdk_query()` only accepts three keyword arguments (`prompt`, `options`, `transport`), but openclawpack's `ClaudeTransport.run()` passes `can_use_tool` and `hooks` as extra kwargs to `sdk_query()`. The SDK expects `can_use_tool` and `hooks` to be set as fields on the `ClaudeAgentOptions` dataclass, not as function kwargs. This means any command that uses answer injection (new-project, plan-phase, execute-phase) will raise a `TypeError` at runtime.

The second bug is that CLI commands do not catch `TransportError` exceptions, so when Claude Code CLI is not installed, users see a raw Python traceback instead of structured JSON error output. The third bug is that `verbose`/`quiet` flags are accepted by the CLI and passed to `WorkflowEngine`, but the engine never forwards them to the transport layer or SDK.

**Primary recommendation:** Fix the `can_use_tool`/`hooks` wiring in `client.py`, add top-level try/except in CLI commands or engine, and wire verbose flag through to the SDK's `stderr` callback on `ClaudeAgentOptions`.

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| CMD-05 | Pre-filled answer injection converts agent-supplied parameters into GSD --auto mode document format | Fix `can_use_tool`/`hooks` wiring so answer injection actually reaches the SDK. Currently broken by `sdk_query()` signature mismatch. |
| CMD-07 | All commands accept `--verbose` for detailed subprocess output and `--quiet` for minimal output | Wire `verbose` flag through `WorkflowEngine` -> `TransportConfig` -> `ClaudeAgentOptions.stderr` callback. `quiet` flag already works (suppresses _output). |
</phase_requirements>

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| claude-agent-sdk | 0.1.39 | Claude Code subprocess control | Only supported Python SDK for Claude Code |
| pydantic | 2.x | CommandResult output models | Already in use, required by PKG-03 |
| typer | 0.x | CLI framework | Already in use |
| anyio | 4.x | Async runtime bridge | Already in use for sync-to-async wrappers |

### Supporting

No new libraries needed. This phase is pure wiring fixes.

### Alternatives Considered

None applicable -- this phase fixes bugs in existing code, not adding new capabilities.

**Installation:** No new dependencies.

## Architecture Patterns

### Recommended Project Structure

No structural changes. All fixes are in existing files:

```
src/openclawpack/
  transport/
    client.py         # Fix: can_use_tool/hooks on ClaudeAgentOptions, not sdk_query kwargs
  commands/
    engine.py          # Fix: verbose/quiet forwarding to transport config
  cli.py              # Fix: structured error output wrapping
```

### Pattern 1: ClaudeAgentOptions Field Assignment (can_use_tool / hooks)

**What:** The SDK's `query()` function accepts exactly three kwargs: `prompt`, `options`, `transport`. The `can_use_tool` callback and `hooks` dict must be set as fields on the `ClaudeAgentOptions` dataclass, which is passed via the `options` kwarg.

**When to use:** Always -- this is the only way to pass these to the SDK.

**Evidence (HIGH confidence -- directly verified from installed SDK source):**

The `sdk_query()` function signature (from `/opt/homebrew/Caskroom/miniconda/base/lib/python3.13/site-packages/claude_agent_sdk/query.py`):
```python
async def query(
    *,
    prompt: str | AsyncIterable[dict[str, Any]],
    options: ClaudeAgentOptions | None = None,
    transport: Transport | None = None,
) -> AsyncIterator[Message]:
```

The `ClaudeAgentOptions` dataclass has these relevant fields:
```python
@dataclass
class ClaudeAgentOptions:
    # ... other fields ...
    can_use_tool: CanUseTool | None = None
    hooks: dict[HookEvent, list[HookMatcher]] | None = None
```

**Current broken code in `client.py`:**
```python
# Lines 102-110: Builds sdk_query kwargs with can_use_tool/hooks as separate kwargs
query_kwargs: dict[str, Any] = {
    "prompt": prompt,
    "options": options,
}
if can_use_tool is not None:
    query_kwargs["can_use_tool"] = can_use_tool  # BUG: sdk_query() rejects this
if hooks is not None:
    query_kwargs["hooks"] = hooks  # BUG: sdk_query() rejects this
```

**Fix pattern:**
```python
# Set can_use_tool and hooks on the options object itself
if can_use_tool is not None:
    options.can_use_tool = can_use_tool
if hooks is not None:
    options.hooks = hooks

# sdk_query only takes prompt, options, transport
async with asyncio.timeout(self.config.timeout_seconds):
    async for message in sdk_query(prompt=prompt, options=options):
        if isinstance(message, ResultMessage):
            result_message = message
```

### Pattern 2: Hooks Format Difference

**What:** The `ClaudeAgentOptions.hooks` field expects `dict[HookEvent, list[HookMatcher]]`, but openclawpack currently builds hooks as `{"PreToolUse": <callable>}` (a bare callable, not a list of `HookMatcher` objects).

**Evidence (HIGH confidence -- verified from SDK types.py and internal/client.py):**

The SDK types define:
```python
@dataclass
class HookMatcher:
    matcher: str | None = None
    hooks: list[HookCallback] = field(default_factory=list)
    timeout: float | None = None

HookCallback = Callable[
    [HookInput, str | None, HookContext],
    Awaitable[HookJSONOutput],
]
```

And `ClaudeAgentOptions.hooks` is typed as:
```python
hooks: dict[HookEvent, list[HookMatcher]] | None = None
```

**Current broken code in `engine.py`:**
```python
run_kwargs["hooks"] = {"PreToolUse": build_noop_pretool_hook()}
```

This passes a bare async function where the SDK expects `list[HookMatcher]`. The fix requires wrapping in `HookMatcher`:

```python
from claude_agent_sdk import HookMatcher
run_kwargs["hooks"] = {
    "PreToolUse": [HookMatcher(hooks=[build_noop_pretool_hook()])]
}
```

**IMPORTANT additional finding:** The `build_noop_pretool_hook()` function signature is `async def pre_tool_use(session, event) -> None`, but `HookCallback` expects `(HookInput, str | None, HookContext) -> Awaitable[HookJSONOutput]`. The hook callback signature must be updated to match the SDK's expected types. The return type must be `HookJSONOutput` (a TypedDict), not `None`.

### Pattern 3: can_use_tool Requires Streaming Mode

**What:** The SDK's `InternalClient.process_query()` method raises a `ValueError` if `can_use_tool` is set but the prompt is a plain string. It requires an `AsyncIterable` prompt for the can_use_tool callback to work.

**Evidence (HIGH confidence -- directly from SDK `_internal/client.py` lines 53-59):**
```python
if options.can_use_tool:
    if isinstance(prompt, str):
        raise ValueError(
            "can_use_tool callback requires streaming mode. "
            "Please provide prompt as an AsyncIterable instead of a string."
        )
```

This is a critical integration issue. Currently, `ClaudeTransport.run()` passes the prompt as a plain string:
```python
async for message in sdk_query(prompt=prompt, options=options):
```

**Fix pattern:** When `can_use_tool` is set, the prompt must be wrapped in an async iterable:
```python
async def _wrap_prompt_as_stream(prompt_text: str) -> AsyncIterable[dict[str, Any]]:
    """Convert a string prompt into a streaming-mode async iterable."""
    yield {
        "type": "user",
        "session_id": "",
        "message": {"role": "user", "content": prompt_text},
        "parent_tool_use_id": None,
    }
```

Then pass the iterable instead of the string when `can_use_tool` is present:
```python
if options.can_use_tool is not None:
    prompt_input = _wrap_prompt_as_stream(prompt)
else:
    prompt_input = prompt

async for message in sdk_query(prompt=prompt_input, options=options):
    ...
```

### Pattern 4: Structured Error Output at CLI Boundary

**What:** When `ClaudeTransport` raises `CLINotFound` or any `TransportError`, the CLI commands currently let the exception propagate as an unhandled traceback instead of returning structured JSON.

**Current code (cli.py, e.g., new_project command):**
```python
result = asyncio.run(
    new_project_workflow(
        idea=idea_text,
        project_dir=project_dir,
        verbose=verbose,
        quiet=quiet,
        timeout=timeout,
    )
)
_output(result, quiet)
```

No try/except wraps the `asyncio.run()` call. If the transport layer raises `CLINotFound`, users see a Python traceback.

**Fix pattern:** Wrap at the workflow level (preferred over CLI level to benefit both CLI and future library API):
```python
async def new_project_workflow(...) -> CommandResult:
    try:
        # ... existing workflow code ...
        return await engine.run_gsd_command(...)
    except TransportError as e:
        return CommandResult.error(str(e))
```

OR wrap at the CLI level:
```python
try:
    result = asyncio.run(new_project_workflow(...))
except TransportError as e:
    result = CommandResult.error(str(e))
_output(result, quiet)
```

The workflow-level approach is better because it keeps error handling close to the source and benefits both CLI and library consumers.

### Pattern 5: Verbose Flag Forwarding

**What:** `WorkflowEngine` accepts `verbose` and `quiet` parameters but never uses them. The `verbose` flag should enable subprocess debug output visible to the caller.

The SDK's `ClaudeAgentOptions` has a `stderr` field:
```python
stderr: Callable[[str], None] | None = None  # Callback for stderr output from CLI
```

And a deprecated `debug_stderr` field that defaults to `sys.stderr`.

**Fix pattern:** When `verbose=True`, set `options.stderr` to a callback that writes to `sys.stderr`. When `quiet=True` (or `verbose=False`), set `options.stderr` to a no-op or `None` to suppress debug output:

```python
if self.verbose:
    import sys
    options.stderr = lambda line: print(line, file=sys.stderr)
else:
    options.stderr = None  # suppress
    options.debug_stderr = None  # suppress deprecated field too
```

### Anti-Patterns to Avoid

- **Passing SDK-unknown kwargs to `sdk_query()`:** The function uses `*` (keyword-only) syntax and only accepts `prompt`, `options`, `transport`. Any extra kwargs cause `TypeError`. Always set fields on `ClaudeAgentOptions` instead.
- **Bare callable as hooks value:** The hooks dict values must be `list[HookMatcher]`, not bare callables.
- **String prompt with `can_use_tool`:** The SDK rejects this. Must use `AsyncIterable` prompt when answer injection is active.
- **Catching exceptions at the wrong layer:** Catch `TransportError` in the workflow functions, not deep in the transport layer (which should raise) or only at the CLI layer (which wouldn't help library consumers).

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Streaming prompt wrapper | Custom subprocess I/O | SDK's own async iterable protocol | SDK handles the wire format and control protocol |
| Hook registration | Custom hook dispatch | `HookMatcher` dataclass from SDK | SDK type system validates hook structure |
| Verbose output | Custom subprocess stderr capture | `ClaudeAgentOptions.stderr` callback | SDK already routes stderr through this callback |

**Key insight:** All three fixes are about using the SDK's existing API correctly, not adding custom infrastructure.

## Common Pitfalls

### Pitfall 1: sdk_query() Signature TypeError

**What goes wrong:** Passing `can_use_tool` or `hooks` as kwargs to `sdk_query()` causes `TypeError: query() got an unexpected keyword argument`.
**Why it happens:** The `query()` function uses `*` (keyword-only) and only accepts `prompt`, `options`, `transport`. The design of openclawpack's `client.py` was based on an earlier or assumed SDK API.
**How to avoid:** Set `can_use_tool` and `hooks` directly on the `ClaudeAgentOptions` dataclass before passing to `sdk_query()`.
**Warning signs:** Any `TypeError` from `sdk_query()` in test output.

### Pitfall 2: can_use_tool Requires AsyncIterable Prompt

**What goes wrong:** Even after fixing the kwargs issue, if `can_use_tool` is set on `ClaudeAgentOptions` but the prompt is a plain string, the SDK raises `ValueError("can_use_tool callback requires streaming mode")`.
**Why it happens:** The SDK's control protocol requires streaming mode for bidirectional communication needed by permission callbacks.
**How to avoid:** Wrap string prompts in an async iterable when `can_use_tool` is set.
**Warning signs:** `ValueError` mentioning "streaming mode" in test output.

### Pitfall 3: HookMatcher Structure Mismatch

**What goes wrong:** Passing `{"PreToolUse": some_callable}` as hooks. The SDK expects `{"PreToolUse": [HookMatcher(hooks=[some_callable])]}`.
**Why it happens:** The hooks API is more structured than intuition suggests -- it supports matchers (tool name patterns) and lists of callbacks per event.
**How to avoid:** Always wrap hook callbacks in `HookMatcher` objects.
**Warning signs:** `TypeError` or `AttributeError` when SDK tries to iterate `hooks` values.

### Pitfall 4: HookCallback Signature Mismatch

**What goes wrong:** The `build_noop_pretool_hook()` returns `async def pre_tool_use(session, event) -> None` but the SDK expects `(HookInput, str | None, HookContext) -> Awaitable[HookJSONOutput]`.
**Why it happens:** The hook callback type was assumed from documentation or earlier SDK versions.
**How to avoid:** Match the exact `HookCallback` type alias from SDK types:
```python
async def pre_tool_use(
    input: HookInput, tool_use_id: str | None, context: HookContext
) -> HookJSONOutput:
    return SyncHookJSONOutput()  # empty = no-op
```
**Warning signs:** Callback receives unexpected argument types at runtime.

### Pitfall 5: Test Mocks Hiding Real Bugs

**What goes wrong:** Current tests mock `sdk_query` with permissive `**kwargs` that accept any arguments. This means tests pass even though the real `sdk_query` would reject the extra kwargs.
**Why it happens:** `AsyncMock()` and generic `async def mock_run(prompt, **kwargs)` functions don't enforce the real function signature.
**How to avoid:** Use `spec=` on mocks or create fake query functions that enforce the real 3-argument signature:
```python
async def fake_query(*, prompt, options, transport=None):
    # Only accepts these three kwargs, just like the real sdk_query
    ...
```
**Warning signs:** Tests pass but runtime fails with `TypeError`.

### Pitfall 6: Error Propagation Gap at CLI Boundary

**What goes wrong:** `TransportError` subclasses propagate as unhandled exceptions, producing Python tracebacks instead of structured JSON.
**Why it happens:** The workflow functions and CLI commands have no try/except for transport errors.
**How to avoid:** Catch `TransportError` at the workflow function boundary and return `CommandResult.error(str(e))`.
**Warning signs:** Running CLI commands with Claude Code uninstalled produces a traceback.

## Code Examples

Verified patterns from installed SDK source at `/opt/homebrew/Caskroom/miniconda/base/lib/python3.13/site-packages/claude_agent_sdk/`:

### Fix 1: can_use_tool and hooks on ClaudeAgentOptions

```python
# Source: claude_agent_sdk/types.py lines 716-752, query.py lines 12-17

# CORRECT: Set on options dataclass
options = ClaudeAgentOptions(
    cwd="/my/project",
    permission_mode="bypassPermissions",
    can_use_tool=my_callback,
    hooks={
        "PreToolUse": [HookMatcher(hooks=[my_hook_callback])]
    },
)
result = sdk_query(prompt=prompt, options=options)

# WRONG: Pass as sdk_query kwargs (TypeError)
result = sdk_query(prompt=prompt, options=options, can_use_tool=my_callback)
```

### Fix 2: AsyncIterable Prompt for can_use_tool

```python
# Source: claude_agent_sdk/_internal/client.py lines 53-59

async def as_stream(text: str):
    yield {
        "type": "user",
        "session_id": "",
        "message": {"role": "user", "content": text},
        "parent_tool_use_id": None,
    }

# When can_use_tool is set, use streaming prompt
options = ClaudeAgentOptions(can_use_tool=my_callback)
async for msg in sdk_query(prompt=as_stream("Hello"), options=options):
    ...
```

### Fix 3: HookCallback Signature

```python
# Source: claude_agent_sdk/types.py lines 440-447

from claude_agent_sdk import (
    HookCallback, HookContext, HookInput, HookJSONOutput, HookMatcher
)

async def noop_pretool_hook(
    input: HookInput,
    tool_use_id: str | None,
    context: HookContext,
) -> HookJSONOutput:
    """No-op hook -- allow all tool use without modification."""
    return {}  # empty SyncHookJSONOutput = proceed normally
```

### Fix 4: Structured Error Output

```python
# Pattern for workflow-level error catching

from openclawpack.transport.errors import TransportError

async def new_project_workflow(idea: str, ...) -> CommandResult:
    try:
        engine = WorkflowEngine(...)
        return await engine.run_gsd_command(...)
    except TransportError as e:
        return CommandResult.error(str(e))
```

### Fix 5: Verbose Forwarding

```python
# Source: claude_agent_sdk/types.py line 746

import sys

options = ClaudeAgentOptions(
    stderr=lambda line: print(line, file=sys.stderr) if verbose else None,
)
```

### Fix 6: Strict Test Mock for sdk_query

```python
# Test pattern: enforce real sdk_query signature in mocks

async def fake_query(*, prompt, options, transport=None):
    """Mock that enforces the real sdk_query() signature."""
    # Reject unexpected kwargs (sdk_query uses keyword-only args)
    result = ResultMessage.__new__(ResultMessage)
    result.is_error = False
    result.result = "ok"
    result.session_id = "test-session"
    result.usage = {}
    result.duration_ms = 1
    yield result
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `can_use_tool` as `sdk_query()` kwarg | `can_use_tool` as `ClaudeAgentOptions` field | SDK v0.1.x (always was this way) | Our code was wrong from the start; never tested at runtime |
| `hooks` as simple dict of callables | `hooks` as `dict[HookEvent, list[HookMatcher]]` | SDK v0.1.x design | Hook structure was more complex than assumed |
| String prompt with callbacks | AsyncIterable prompt required for callbacks | SDK v0.1.x design | Streaming mode is required for bidirectional control |

**Deprecated/outdated:**
- `ClaudeAgentOptions.debug_stderr`: Deprecated in SDK v0.1.39. Use `stderr` callback instead.

## Open Questions

1. **HookJSONOutput return format details**
   - What we know: The noop hook must return `HookJSONOutput` (either `AsyncHookJSONOutput` or `SyncHookJSONOutput`).
   - What's unclear: Whether an empty dict `{}` is sufficient for a no-op return, or if specific fields must be set.
   - Recommendation: Start with `{}` (empty SyncHookJSONOutput). The TypedDict fields are all `NotRequired`, so empty dict should work. Verify with a runtime test. **Confidence: MEDIUM** -- inferred from TypedDict definition where all fields are NotRequired.

2. **verbose output granularity**
   - What we know: `ClaudeAgentOptions.stderr` callback receives stderr lines from the CLI subprocess.
   - What's unclear: Whether this provides useful debug output (progress, tool calls, etc.) or just error messages.
   - Recommendation: Wire it up and evaluate output quality during manual testing. The `debug_stderr` (deprecated) field defaulting to `sys.stderr` suggests the SDK does emit useful debug output by default.
   - **Confidence: MEDIUM** -- the stderr callback is documented but output content is undocumented.

3. **Whether noop hook is still needed at all**
   - What we know: The original design required `PreToolUse` hook for `can_use_tool` to fire. The SDK `_internal/client.py` reads `can_use_tool` directly from `ClaudeAgentOptions`, so the hook may no longer be necessary.
   - Looking at `_internal/client.py` line 106: `can_use_tool=configured_options.can_use_tool` -- the SDK reads `can_use_tool` directly and passes it to the `Query` constructor. Hooks are passed separately.
   - What's unclear: Whether `can_use_tool` fires independently of hooks or requires a `PreToolUse` hook to be registered.
   - Recommendation: Test without the noop hook first. If `can_use_tool` doesn't fire, add the hook back. **Confidence: MEDIUM** -- the SDK code suggests they're independent paths, but not definitively proven.

## Sources

### Primary (HIGH confidence)
- **claude-agent-sdk v0.1.39 source code** (installed at `/opt/homebrew/Caskroom/miniconda/base/lib/python3.13/site-packages/claude_agent_sdk/`) -- directly inspected `query.py`, `types.py`, `__init__.py`, `_internal/client.py`
- **openclawpack source code** -- all files in `src/openclawpack/` and `tests/`
- **Test suite execution** -- 210 unit tests pass, confirming current codebase health

### Secondary (MEDIUM confidence)
- SDK TypedDict definitions for `HookJSONOutput` -- inferred behavior from type structure
- `ClaudeAgentOptions.stderr` callback -- field exists and is typed but behavior inferred from field name and deprecation note

### Tertiary (LOW confidence)
- None. All findings verified against installed SDK source code.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new libraries, all fixes in existing code
- Architecture: HIGH - All three bugs verified against installed SDK v0.1.39 source
- Pitfalls: HIGH - Every pitfall identified from direct source code comparison
- Code examples: HIGH - Patterns derived from actual SDK type definitions and function signatures

**Research date:** 2026-02-22
**Valid until:** 2026-03-22 (stable -- SDK v0.1.x API is unlikely to change for these core features within 30 days)
