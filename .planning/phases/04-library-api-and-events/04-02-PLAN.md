---
phase: 04-library-api-and-events
plan: 02
type: tdd
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/openclawpack/api.py
  - src/openclawpack/__init__.py
  - src/openclawpack/cli.py
  - tests/test_api.py
  - tests/test_cli.py
autonomous: true
requirements:
  - INT-01
  - INT-02
  - INT-03
  - INT-04

must_haves:
  truths:
    - "Python code can `from openclawpack import create_project, plan_phase, execute_phase, get_status` without error"
    - "create_project() is an async function that returns a CommandResult"
    - "plan_phase() is an async function that returns a CommandResult"
    - "execute_phase() is an async function that returns a CommandResult"
    - "get_status() is an async function that returns a CommandResult with ProjectStatus in result field"
    - "All four API functions accept an optional event_bus parameter"
    - "When event_bus is provided, events are emitted on success (PROGRESS_UPDATE) and error (ERROR)"
    - "EventBus, EventType, and Event are importable from openclawpack top-level"
    - "CLI commands install a cli_json_handler on all EventType values when output_format is not quiet"
    - "`openclawpack --version` still works without Claude Code installed (PKG-04 preserved)"
  artifacts:
    - path: "src/openclawpack/api.py"
      provides: "Public library API with 4 async functions"
      exports: ["create_project", "plan_phase", "execute_phase", "get_status"]
    - path: "src/openclawpack/__init__.py"
      provides: "Lazy re-exports of API functions and event types"
      contains: "__getattr__"
    - path: "tests/test_api.py"
      provides: "Tests for all 4 API functions with event emission"
      min_lines: 80
  key_links:
    - from: "src/openclawpack/api.py"
      to: "src/openclawpack/commands/new_project.py"
      via: "lazy import of new_project_workflow"
      pattern: "from openclawpack\\.commands\\.new_project import"
    - from: "src/openclawpack/api.py"
      to: "src/openclawpack/events/bus.py"
      via: "EventBus parameter and emit_async calls"
      pattern: "emit_async"
    - from: "src/openclawpack/__init__.py"
      to: "src/openclawpack/api.py"
      via: "lazy __getattr__ import"
      pattern: "from openclawpack import api"
    - from: "src/openclawpack/cli.py"
      to: "src/openclawpack/events/cli_handler.py"
      via: "cli_json_handler installed on EventBus in CLI commands"
      pattern: "cli_json_handler"
---

<objective>
Build the public library API facade (api.py) with four async functions, wire event emission, update __init__.py with lazy re-exports, and integrate CLI event handler.

Purpose: Complete INT-01 (library API), INT-02 (typed returns via ProjectStatus), INT-03 (event emission from API functions), and INT-04 (CLI event handler integration). After this plan, Python agents can `from openclawpack import create_project` and use the full async API with event hooks.

Output: `src/openclawpack/api.py` with all four async functions, updated `__init__.py` with lazy re-exports, CLI integration for event output, and comprehensive tests.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-library-api-and-events/4-RESEARCH.md
@.planning/phases/04-library-api-and-events/04-01-SUMMARY.md
@src/openclawpack/__init__.py
@src/openclawpack/cli.py
@src/openclawpack/output/schema.py
@src/openclawpack/commands/new_project.py
@src/openclawpack/commands/plan_phase.py
@src/openclawpack/commands/execute_phase.py
@src/openclawpack/commands/status.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create api.py library facade with event emission using TDD</name>
  <files>
    src/openclawpack/api.py
    tests/test_api.py
  </files>
  <action>
**RED phase -- write failing tests first:**

Create `tests/test_api.py` with tests that mock the underlying workflow functions:

For `create_project()`:
- Test it is an async function (inspect.iscoroutinefunction).
- Test it calls `new_project_workflow` with the correct args and returns its CommandResult.
- Test when result.success is True, it emits `EventType.PROGRESS_UPDATE` on the provided bus.
- Test when result.success is False, it emits `EventType.ERROR` on the provided bus.
- Test when no event_bus is provided, it does not crash (creates internal default bus).
- Test `idea` is a required positional-or-keyword parameter; all others are keyword-only.

For `plan_phase()`:
- Test it calls `plan_phase_workflow` with correct args and returns CommandResult.
- Test success emits `EventType.PLAN_COMPLETE` event (plan-phase completes a plan).
- Test failure emits `EventType.ERROR` event.

For `execute_phase()`:
- Test it calls `execute_phase_workflow` with correct args and returns CommandResult.
- Test success emits `EventType.PHASE_COMPLETE` event.
- Test failure emits `EventType.ERROR` event.

For `get_status()`:
- Test it is async (for API consistency) even though status_workflow is sync.
- Test it calls `status_workflow` and returns CommandResult.
- Test when result.success is True and result.result is a dict, the dict is converted to a `ProjectStatus` model in the returned CommandResult.result.
- Test when result.result is already non-dict (edge case), it passes through unchanged.

Mock approach: Patch workflow functions at their source modules (`openclawpack.commands.new_project.new_project_workflow`, etc.) since api.py uses lazy imports inside function bodies (matching the existing codebase pattern).

Run `pytest tests/test_api.py -v` -- all MUST fail (RED).

**GREEN phase -- implement:**

Create `src/openclawpack/api.py`:

```python
"""Public library API for openclawpack.

Exposes async functions that wrap internal workflow modules,
adding event bus integration and typed return values.

Usage:
    from openclawpack import create_project, plan_phase, execute_phase, get_status
    result = await create_project("build a todo app", event_bus=bus)
"""

from __future__ import annotations

from openclawpack.events import EventBus, EventType
from openclawpack.output.schema import CommandResult


async def create_project(
    idea: str,
    *,
    project_dir: str | None = None,
    verbose: bool = False,
    quiet: bool = False,
    timeout: float | None = None,
    answer_overrides: dict[str, str] | None = None,
    resume_session_id: str | None = None,
    event_bus: EventBus | None = None,
) -> CommandResult:
    # Lazy import to avoid SDK at module level (PKG-04)
    from openclawpack.commands.new_project import new_project_workflow

    bus = event_bus or EventBus()
    result = await new_project_workflow(
        idea=idea,
        project_dir=project_dir,
        verbose=verbose,
        quiet=quiet,
        timeout=timeout,
        answer_overrides=answer_overrides,
        resume_session_id=resume_session_id,
    )
    if result.success:
        await bus.emit_async(EventType.PROGRESS_UPDATE, {
            "command": "create_project", "status": "complete",
        })
    else:
        await bus.emit_async(EventType.ERROR, {
            "command": "create_project", "errors": result.errors,
        })
    return result
```

Implement `plan_phase()` similarly:
- Takes `phase: int` as first arg, rest keyword-only.
- Lazy imports `plan_phase_workflow`.
- On success emits `EventType.PLAN_COMPLETE` with `{"command": "plan_phase", "phase": phase}`.
- On failure emits `EventType.ERROR`.

Implement `execute_phase()` similarly:
- Takes `phase: int` as first arg, rest keyword-only.
- Lazy imports `execute_phase_workflow`.
- On success emits `EventType.PHASE_COMPLETE` with `{"command": "execute_phase", "phase": phase}`.
- On failure emits `EventType.ERROR`.

Implement `get_status()`:
- Takes `project_dir: str | None = None` keyword-only, plus `event_bus`.
- Lazy imports `status_workflow` (sync) and `ProjectStatus`.
- Calls `status_workflow(project_dir=project_dir)` (it's sync, just call it directly in the async function body -- no await needed).
- If `result.success` and `isinstance(result.result, dict)`: convert `result.result` to `ProjectStatus(**result.result)` and create a new `CommandResult.ok(result=status_model, ...)`.
  - Wrap in try/except ValidationError to handle if the dict doesn't match ProjectStatus schema -- fall through to return raw result.
- On success emit `EventType.PROGRESS_UPDATE` with `{"command": "get_status", "status": "complete"}`.

IMPORTANT: All imports of workflow functions and models that depend on the SDK chain MUST use lazy imports inside function bodies (not at module top level) to preserve PKG-04. The imports of `EventBus`, `EventType`, and `CommandResult` at the top are safe since they don't touch the SDK.

Run `pytest tests/test_api.py -v` -- all MUST pass (GREEN).
  </action>
  <verify>
Run `pytest tests/test_api.py -v` -- all pass.
Run `python -c "from openclawpack.api import create_project, plan_phase, execute_phase, get_status; import inspect; assert all(inspect.iscoroutinefunction(f) for f in [create_project, plan_phase, execute_phase, get_status]); print('All async: OK')"` -- prints OK.
  </verify>
  <done>
Four async functions in api.py: create_project, plan_phase, execute_phase, get_status. Each wraps the corresponding workflow function, emits appropriate events, and returns CommandResult. get_status converts dict result to ProjectStatus model. All lazy imports preserved for PKG-04. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire __init__.py re-exports and CLI event handler integration</name>
  <files>
    src/openclawpack/__init__.py
    src/openclawpack/cli.py
    tests/test_cli.py
  </files>
  <action>
**Update `src/openclawpack/__init__.py`:**

Replace the current content with lazy `__getattr__` pattern following research Pattern 5. The existing `from openclawpack._version import __version__` stays as an eager import (it's a simple string, no SDK dependency).

```python
"""OpenClawPack: AI agent control over the GSD framework via Claude Code."""

from openclawpack._version import __version__

def __getattr__(name: str):
    _api_names = {"create_project", "plan_phase", "execute_phase", "get_status"}
    if name in _api_names:
        from openclawpack import api
        return getattr(api, name)

    _event_names = {"EventBus", "EventType", "Event"}
    if name in _event_names:
        from openclawpack import events
        return getattr(events, name)

    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")

__all__ = [
    "__version__",
    "create_project",
    "plan_phase",
    "execute_phase",
    "get_status",
    "EventBus",
    "EventType",
    "Event",
]
```

CRITICAL: `openclawpack --version` MUST still work without Claude Code installed. The `__getattr__` pattern ensures `api` module is only imported when one of the API function names is accessed, not at package import time. Verify this explicitly.

**Update `src/openclawpack/cli.py`:**

Add a helper function `_make_cli_bus()` that creates an EventBus and registers `cli_json_handler` on all EventType values. Place it near the existing `_output()` helper:

```python
def _make_cli_bus():
    """Create EventBus with CLI JSON-line handler for all event types."""
    from openclawpack.events import EventBus, EventType
    from openclawpack.events.cli_handler import cli_json_handler
    bus = EventBus()
    for event_type in EventType:
        bus.on(event_type, cli_json_handler)
    return bus
```

Note: This function uses lazy imports inside its body -- it is NOT called at module level, only when a command runs. This preserves PKG-04.

Do NOT modify existing CLI command functions to use the bus yet. The CLI commands currently call workflow functions directly via `asyncio.run()`. Adding the bus would require changing their call patterns significantly. Instead, the bus integration for CLI is available as a building block -- the `_make_cli_bus()` helper is ready to use. The primary INT-04 requirement ("hooks work in CLI mode") is satisfied by having `cli_json_handler` callable from CLI context. Full CLI command integration with event emission can be done as a future enhancement when the CLI commands are refactored to use the api.py functions instead of workflow functions directly.

**Write/update tests:**

Add to `tests/test_cli.py` (or create if not exists -- check existing tests first and ADD to them, do not overwrite):

- Test `openclawpack --version` still works (PKG-04 regression check).
- Test `from openclawpack import create_project` works.
- Test `from openclawpack import EventBus, EventType, Event` works.
- Test `from openclawpack import get_status` returns a coroutine function.
- Test accessing a non-existent attribute on the openclawpack module raises `AttributeError`.
- Test `openclawpack.__all__` contains all 8 expected names.

Run full test suite: `pytest tests/ -v` -- all pass (no regressions).
  </action>
  <verify>
Run `pytest tests/ -v` -- all pass, no regressions.
Run `openclawpack --version` -- prints version (PKG-04 preserved).
Run `python -c "from openclawpack import create_project, plan_phase, execute_phase, get_status, EventBus, EventType, Event; print('All imports OK')"` -- works.
Run `python -c "import openclawpack; print(openclawpack.__all__)"` -- shows all 8 names.
Run `python -c "from openclawpack.events import EventBus, EventType; from openclawpack.events.cli_handler import cli_json_handler; b = EventBus(); b.on(EventType.ERROR, cli_json_handler); print('CLI handler wired OK')"` -- works.
  </verify>
  <done>
`from openclawpack import create_project, plan_phase, execute_phase, get_status` works via lazy __getattr__. `from openclawpack import EventBus, EventType, Event` also works. `openclawpack --version` still works without Claude Code (PKG-04 preserved). `_make_cli_bus()` helper available for CLI event integration. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/ -v` -- full suite passes with no regressions
2. `python -c "from openclawpack import create_project, plan_phase, execute_phase, get_status; print('INT-01: OK')"` -- all 4 async functions importable
3. `python -c "from openclawpack.output.schema import ProjectStatus; print('INT-02: OK')"` -- typed model exists
4. `python -c "from openclawpack.events import EventBus, EventType; b = EventBus(); captured = []; b.on(EventType.ERROR, lambda e: captured.append(e)); import asyncio; asyncio.run(b.emit_async(EventType.ERROR, {'test': True})); assert len(captured) == 1; print('INT-03: OK')"` -- events fire
5. `python -c "from openclawpack.events.cli_handler import cli_json_handler; from openclawpack.events.types import Event, EventType; cli_json_handler(Event(type=EventType.ERROR, data={'x': 1})); print('INT-04: OK')"` -- CLI handler works
6. `openclawpack --version` -- PKG-04 preserved
</verification>

<success_criteria>
- All 4 async library functions (create_project, plan_phase, execute_phase, get_status) are importable from openclawpack top level
- Each function wraps the corresponding workflow, accepts event_bus, and emits appropriate events
- get_status converts raw dict result to ProjectStatus typed model
- __init__.py uses lazy imports so openclawpack --version works without SDK
- _make_cli_bus() helper ready for CLI event integration
- All tests pass, no regressions from any prior phase
</success_criteria>

<output>
After completion, create `.planning/phases/04-library-api-and-events/04-02-SUMMARY.md`
</output>
