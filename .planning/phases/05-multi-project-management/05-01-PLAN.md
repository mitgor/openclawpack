---
phase: 05-multi-project-management
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/openclawpack/state/models.py
  - src/openclawpack/state/registry.py
  - src/openclawpack/state/__init__.py
  - tests/test_state/test_registry.py
autonomous: true
requirements:
  - STATE-03

must_haves:
  truths:
    - "ProjectRegistry.add() stores a project entry with resolved path, name, timestamp, and state snapshot"
    - "ProjectRegistry.list_projects() returns all registered entries"
    - "ProjectRegistry.remove() deletes an entry by name and returns True, or returns False if not found"
    - "Registry persists to a JSON file in the platform-appropriate user data directory"
    - "Adding a path without .planning/ raises ValueError"
    - "Adding a duplicate name raises ValueError"
    - "Adding a duplicate resolved path raises ValueError"
    - "Loading a non-existent registry file returns an empty registry"
    - "Atomic write prevents file corruption on crash"
  artifacts:
    - path: "src/openclawpack/state/models.py"
      provides: "RegistryEntry and ProjectRegistryData Pydantic models"
      contains: "class RegistryEntry"
    - path: "src/openclawpack/state/registry.py"
      provides: "ProjectRegistry class with load/save/add/remove/list_projects and cross-platform data dir"
      exports: ["ProjectRegistry"]
    - path: "tests/test_state/test_registry.py"
      provides: "TDD tests for registry CRUD, persistence, validation, and edge cases"
      min_lines: 100
  key_links:
    - from: "src/openclawpack/state/registry.py"
      to: "src/openclawpack/state/models.py"
      via: "imports RegistryEntry, ProjectRegistryData"
      pattern: "from openclawpack\\.state\\.models import RegistryEntry"
    - from: "src/openclawpack/state/registry.py"
      to: "src/openclawpack/state/reader.py"
      via: "calls get_project_summary() for state snapshots"
      pattern: "get_project_summary"
    - from: "src/openclawpack/state/__init__.py"
      to: "src/openclawpack/state/registry.py"
      via: "re-exports ProjectRegistry"
      pattern: "ProjectRegistry"
---

<objective>
Create the data layer for multi-project management: Pydantic models for registry entries and the ProjectRegistry class that provides CRUD operations with atomic JSON persistence in a cross-platform user data directory.

Purpose: STATE-03 requires a persistent registry that tracks registered projects with paths and last-known state. This plan builds the foundation that the CLI and API layers (Plan 02) will consume.

Output: Working, tested ProjectRegistry class with RegistryEntry/ProjectRegistryData models, atomic file persistence, and cross-platform data directory resolution.
</objective>

<execution_context>
@/Users/mit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-project-management/05-RESEARCH.md
@src/openclawpack/state/models.py
@src/openclawpack/state/reader.py
@src/openclawpack/state/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Registry models and ProjectRegistry class with TDD</name>
  <files>
    src/openclawpack/state/models.py
    src/openclawpack/state/registry.py
    src/openclawpack/state/__init__.py
    tests/test_state/test_registry.py
  </files>
  <action>
**RED phase -- Write failing tests first in `tests/test_state/test_registry.py`:**

Test the following behaviors:

1. **RegistryEntry model:** Create RegistryEntry with name, path, registered_at (ISO 8601 string), optional last_checked_at, optional last_known_state (dict). Verify Pydantic round-trip with model_dump()/model_validate().

2. **ProjectRegistryData model:** Create with version=1 default and projects=dict[str, RegistryEntry] default empty. Verify model_dump_json()/model_validate_json() round-trip.

3. **_user_data_dir():** Returns a Path. On macOS returns `~/Library/Application Support/openclawpack`. On Linux returns `~/.local/share/openclawpack` (or XDG_DATA_HOME if set). Test by monkeypatching `sys.platform` and `os.environ`.

4. **ProjectRegistry.load():** When registry file does not exist, returns ProjectRegistry with empty projects. When file exists with valid JSON, loads correctly. When file has invalid JSON, raises ValueError.

5. **ProjectRegistry.save():** Writes JSON to the registry file path. File is valid JSON after save. Uses atomic write (test by verifying file content matches expected after save -- do NOT mock internals of atomic write).

6. **ProjectRegistry.add():**
   - Given a valid project path (with `.planning/` dir), creates RegistryEntry with resolved path, derived name (directory basename), ISO timestamp, and state snapshot from `get_project_summary()`.
   - Given a path without `.planning/`, raises ValueError with descriptive message.
   - Given a path that doesn't exist, raises ValueError.
   - Given a name that already exists in registry, raises ValueError.
   - Given a path that resolves to an already-registered path, raises ValueError.
   - Optional `name` parameter overrides the derived name.
   - After add, registry has one more entry and auto-saves.

7. **ProjectRegistry.remove():**
   - Given an existing name, removes the entry, auto-saves, returns True.
   - Given a non-existent name, returns False, does not save.

8. **ProjectRegistry.list_projects():**
   - Returns list of RegistryEntry objects.
   - Empty registry returns empty list.
   - After adding 2 projects, returns 2 entries.

9. **Persistence round-trip:** Add a project, create a new ProjectRegistry.load() from the same path, verify the entry is present.

Use `tmp_path` pytest fixture for all file operations. Mock `get_project_summary()` to return a predictable dict. Create a fake GSD project structure in tmp_path (just `mkdir .planning` is sufficient for validation).

**GREEN phase -- Implement to make tests pass:**

Add to `src/openclawpack/state/models.py`:

```python
class RegistryEntry(BaseModel):
    """A single registered project in the multi-project registry."""
    name: str
    path: str  # Absolute, resolved path
    registered_at: str  # ISO 8601 timestamp
    last_checked_at: str | None = None
    last_known_state: dict[str, Any] | None = None

class ProjectRegistryData(BaseModel):
    """Persistent registry of all registered GSD projects."""
    version: int = 1
    projects: dict[str, RegistryEntry] = Field(default_factory=dict)
```

Add `Any` to the imports from `typing` in models.py. Add `Field` to pydantic imports if not already there.

Create `src/openclawpack/state/registry.py`:

```python
class ProjectRegistry:
    """Manages a persistent JSON registry of GSD projects.

    Provides CRUD operations with atomic file persistence in a
    cross-platform user data directory.
    """

    def __init__(self, registry_path: Path | None = None):
        # If registry_path is None, use _user_data_dir() / "registry.json"
        # Load data from file or create empty ProjectRegistryData

    @classmethod
    def load(cls, registry_path: Path | None = None) -> ProjectRegistry:
        # Factory: create instance, load from file if exists

    def save(self) -> None:
        # Atomic write: tempfile.mkstemp + os.fdopen + os.replace

    def add(self, path: str | Path, *, name: str | None = None) -> RegistryEntry:
        # Validate: path exists, has .planning/, name unique, path unique
        # Resolve path, derive name from basename if not provided
        # Snapshot state via get_project_summary()
        # Create RegistryEntry, add to data.projects, save, return entry

    def remove(self, name: str) -> bool:
        # If name in data.projects: delete, save, return True
        # Else: return False

    def list_projects(self) -> list[RegistryEntry]:
        # Return list(data.projects.values())
```

Implement `_user_data_dir(appname="openclawpack") -> Path` as a module-level function following the research pattern: macOS -> `~/Library/Application Support/openclawpack`, Linux -> `$XDG_DATA_HOME/openclawpack` or `~/.local/share/openclawpack`, Windows -> `%LOCALAPPDATA%/openclawpack`.

Implement `_atomic_write_json(path: Path, data: str) -> None` following the research pattern: `tempfile.mkstemp()` in same dir, write, fsync, `os.replace()`, cleanup on error.

Update `src/openclawpack/state/__init__.py` to add `RegistryEntry`, `ProjectRegistryData`, and `ProjectRegistry` to imports and `__all__`.

**REFACTOR phase:** Clean up any duplication. Ensure docstrings on all public methods.
  </action>
  <verify>
Run `python -m pytest tests/test_state/test_registry.py -v` -- all tests pass.
Run `python -m pytest tests/ -v` -- no regressions in existing tests.
Run `python -c "from openclawpack.state import ProjectRegistry, RegistryEntry, ProjectRegistryData; print('imports ok')"` -- prints "imports ok".
Run `python -c "from openclawpack._version import __version__; print(__version__)"` -- PKG-04 still works (no eager import chain).
  </verify>
  <done>
RegistryEntry and ProjectRegistryData Pydantic models exist with JSON round-trip. ProjectRegistry class supports load/save/add/remove/list_projects with atomic file persistence. Cross-platform data dir resolves correctly. All validation edge cases tested (missing .planning/, duplicate name, duplicate path, non-existent path, empty registry load). Tests pass and no regressions.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_state/test_registry.py -v` -- all registry tests pass
- `python -m pytest tests/ -v` -- full test suite passes with no regressions
- `python -c "from openclawpack.state import ProjectRegistry"` -- import works
- `openclawpack --version` -- PKG-04 still works (no eager import of registry at CLI level)
</verification>

<success_criteria>
- RegistryEntry model stores name, path (resolved), registered_at, last_checked_at, last_known_state
- ProjectRegistryData model stores version and projects dict keyed by name
- ProjectRegistry.load() returns empty registry when file doesn't exist
- ProjectRegistry.add() validates path, checks duplicates, snapshots state, persists atomically
- ProjectRegistry.remove() deletes by name, returns bool, persists
- ProjectRegistry.list_projects() returns all entries
- Cross-platform data dir resolves per platform conventions
- Atomic write prevents corruption (tempfile + os.replace pattern)
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-project-management/05-01-SUMMARY.md`
</output>
